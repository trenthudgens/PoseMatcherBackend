import numpy as np


def center_points(points):
    """Center points around their centroid."""
    centroid = np.mean(points, axis=0)

    return points - centroid, centroid


def MJPE(A, B):
    differences = A - B
    distances = np.linalg.norm(differences, axis=1)
    MJPE = np.mean(distances)

    return MJPE


# hard coded example pose 1
boxes1 = [[389.92864990234375, 91.395751953125, 314.0084228515625, 553.6902465820312, 0.9752058386802673]]
poses3d1 = [[[-152.37403869628906, -198.03408813476562, 2981.69873046875], [-64.11166381835938, -154.12896728515625, 2992.5009765625], [-203.8190460205078, -147.40121459960938, 3044.52490234375], [-161.03530883789062, -283.52606201171875, 2941.370361328125], [-74.84883117675781, 23.32480812072754, 2722.176513671875], [-401.4239196777344, 110.40135192871094, 2840.915283203125], [-220.47256469726562, -288.631591796875, 2816.407958984375], [-19.005626678466797, 438.31768798828125, 2886.00732421875], [-246.7926788330078, 425.19482421875, 2950.734130859375], [-242.8381805419922, -261.18829345703125, 2766.85595703125], [-20.9880313873291, 512.843994140625, 2804.6396484375], [-324.39215087890625, 510.2901916503906, 2897.265869140625], [-331.8981628417969, -298.92767333984375, 2570.907958984375], [-212.649658203125, -295.79852294921875, 2629.11865234375], [-374.7069396972656, -290.8524169921875, 2693.61279296875], [-357.62884521484375, -271.7416687011719, 2503.72802734375], [-125.0746841430664, -232.325927734375, 2569.260498046875], [-474.216796875, -227.1268310546875, 2708.55126953125], [18.57621955871582, -22.323755264282227, 2646.679443359375], [-446.484375, -14.5556001663208, 2864.048095703125], [49.337806701660156, 251.0520477294922, 2658.7373046875], [-456.21612548828125, 219.1435089111328, 2855.31396484375], [55.457763671875, 316.00506591796875, 2665.684814453125], [-463.19073486328125, 271.5249938964844, 2848.88330078125]]]
# hard coded example pose 2
boxes2 = [[344.8481750488281, 156.5441131591797, 302.93890380859375, 448.9589538574219, 0.6414614319801331]]
poses3d2 = [[[119.62043762207031, 190.4342498779297, 2021.9759521484375], [70.48688507080078, 267.42193603515625, 2001.7158203125], [183.81655883789062, 263.4970397949219, 2058.8564453125], [132.21780395507812, 93.97761535644531, 1961.3411865234375], [-256.01483154296875, 266.45672607421875, 2275.45654296875], [201.0844268798828, 262.4756164550781, 2446.612060546875], [89.92277526855469, -29.274768829345703, 1995.025390625], [-33.45775604248047, 563.594482421875, 2100.389404296875], [228.9085235595703, 564.3944091796875, 2204.59814453125], [74.43070220947266, -67.13565826416016, 2040.685546875], [-127.0276870727539, 644.2676391601562, 2185.7861328125], [245.8227081298828, 616.5551147460938, 2332.68994140625], [52.346588134765625, -273.517822265625, 2074.25244140625], [-3.2846202850341797, -178.17050170898438, 2005.841552734375], [135.5632781982422, -191.3593292236328, 2076.356201171875], [17.523155212402344, -295.87249755859375, 2144.55859375], [-78.2584457397461, -189.40853881835938, 1950.9312744140625], [228.3542938232422, -212.7278289794922, 2099.735107421875], [-135.04067993164062, -52.67658615112305, 1784.420166015625], [449.0589904785156, -74.98323059082031, 2055.13330078125], [-190.9935760498047, -215.0187530517578, 1936.3482666015625], [369.5859375, -219.0644073486328, 2260.42822265625], [-200.1470489501953, -271.57464599609375, 1962.775146484375], [347.045166015625, -287.7209167480469, 2302.42431640625]]]


# remove a dimension and convert to numpy array
poses3d1, poses3d2 = np.array(poses3d1[0], np.float32), np.array(poses3d2[0], np.float32)

# center
A_centered, A_centroid = center_points(poses3d1)
B_centered, B_centroid = center_points(poses3d2)

# scaling
dist_A = np.linalg.norm(A_centered, axis=1)
dist_B = np.linalg.norm(B_centered, axis=1)
scale_factor = np.sum(dist_B) / np.sum(dist_A)

A_scaled = A_centered * scale_factor

# rotation
H = np.dot(A_scaled.T, B_centered)
# Perform Singular Value Decomposition
U, S, Vt = np.linalg.svd(H)
R = np.dot(Vt.T, U.T)

# Ensure a right-handed coordinate system if reflection is detected
if np.linalg.det(R) < 0:
    Vt[-1, :] *= -1
    R = np.dot(Vt.T, U.T)

B_rotated = np.dot(B_centered, R)

print(MJPE(poses3d1, poses3d2))                 # Compare original mean joint positional difference between the two poses (score)
print(MJPE(A_centered, B_centered))             # Compare MJPE after centering
print(MJPE(A_scaled, B_rotated))                # Compare MJPE after scaling + rotation
